# Flyweight
複数のオブジェクト間で共通する部分を各自で持つ代わりに共有することによって、利用可能な RAM により多くのオブジェクトを収められるようにする

![flyweight](https://refactoring.guru/images/patterns/content/flyweight/flyweight.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/flyweight/structure-indexed.png)

1. Flyweight パターンは最適化にすぎません。 適用前、 プログラムに、 メモリ内に大量の同じようなオブジェクトが同時に存在することに起因する RAM 消費問題があることを確認してください。 この問題が別の方法では解決できないことを確認してください。

2. フライウェイト （Flyweight） クラスは、 元のオブジェクトの状態のうち、 複数のオブジェクト間で共有できる部分を含んでいます。 同じフライウェイトオブジェクトを多くの異なるコンテキストで使用することができます。 フライウェイト内部に格納されている状態は内因的、 フライウェイトのメソッドに渡される状態は外因的と呼ばれます。

3. コンテキスト （Context） クラスには、 すべての元のオブジェクトで一意の、 外因的状態が含まれています。 コンテキストは、 フライウェイト・オブジェクトのいずれかと組になることによって、 元のオブジェクトの状態を完全に表現します。

4. 通常、 元のオブジェクトの振る舞いは、 フライウェイト・クラスに残ります。 この場合、 フライウェイトのメソッドを呼び出す際に、 メソッドのパラメーターに外因的状態に関する適切な情報を渡す必要があります。 あるいは、 この振る舞いはコンテキスト・クラスに移動することもできます。 この場合、 リンクされたフライウェイトは、 単なるデータ・オブジェクトとして使用することになります。

5. クライアント （Client） は、 フライウェイトの外因的状態を算出するか保存します。 クライアントの視点からすると、 フライウェイトは、 コンテキスト・データをメソッドのパラメーターに渡すことで実行時に設定可能なテンプレート・オブジェクトです。

6. フライウェイト・ファクトリー （Flyweight Factory） は、 既存のフライウェイトのプールを管理します。 ファクトリーがあるため、 クライアントはフライウェイトを直接作成しません。 代わりに、 ファクトリーを呼び出し、 望むフライウェイトの内因的状態を指定する情報を渡します。 ファクトリーは、 以前に作成されたフライウェイトを見渡して、 検索条件に一致する既存のものを返すか、 何も見つからない場合は新しいものを作成します。

## 実装方法
1. フライウェイトになるクラスのフィールドを二つの部分に分割します。

  - 内因的状態： 多くのオブジェクト間で繰り返し現れる不変のデータを含むフィールド
  - 外因的状態： オブジェクトに固有のコンテキスト・データを含むフィールド

2. 内因的状態を表すフィールドはクラス内に残し変更不可とします。 コンストラクターの初期値を取る必要があります。

3. 外因的状態のフィールドを使用するメソッドを一つずつ調べます。 メソッドに新しいパラメーターを導入し、 フィールドの代わりに使用します。

4. 必要に応じて、 フライウェイトのプールを管理するファクトリー・クラスを作成します。 それは、 新しいフライウェイトを作成する前に、 既存のものがないことを確認します。 ファクトリーができたところで、 クライアントは、 ファクトリーを通してのみフライウェイトを要求しなければなりません。 どのようなフライウェイトが欲しいかを知らせるために、 ファクトリーに内因的状態を渡します。

5. フライウェイト・オブジェクトのメソッドを呼び出せるようにするため、 クライアントは外因的状態 （コンテキスト） の値を保管するか計算する必要があります。 これを容易にするため、 外因的状態とフライウェイト参照フィールドを別のコンテキスト・クラスに移動することもできます。

## 他のパターンとの関係
- RAM を節約するために、 Composite ツリーの共有リーフ・ノードを Flyweights として実装できます。

- Flyweight は多くの小さなオブジェクトを作る方法についてですが、 Facade はサブシステム全体を表す単一のオブジェクトを作る方法に関してです。

- Flyweight で、 共有状態の全部を一つのフライウェイト・オブジェクトに何らかの方法で削減できた場合、 それは Singleton に似たものになります。 しかし、 この二つのパターンには、 根本的な違いが二箇所あります。
  1. Singleton のインスタンスは一つだけですが、 Flyweight クラスは、 異なる内因的状態を持つ複数のインスタンスがある可能性があります。
  2. Singleton オブジェクトは変更可能かもしれませんが、 Flyweight のオブジェクトは不変です。

## 引用元

> https://refactoring.guru/ja/design-patterns/flyweight
> https://refactoring.guru/images/patterns/content/flyweight/flyweight.png
> https://refactoring.guru/images/patterns/diagrams/flyweight/structure-indexed.png