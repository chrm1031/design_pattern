# Proxy

他のオブジェクトの代理、代用を提供する
プロキシーは元のオブジェクトへのアクセスを制御し、元のオブジェクトへリクエストが行く前か後に別の何かを行うようにすることができる

![proxy](https://refactoring.guru/images/patterns/content/proxy/proxy.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/proxy/structure-indexed.png)

1. サービス・インターフェース（Service Interface）は、サービスのインターフェースを宣言します。プロキシーは、サービス・オブジェクトのふりをするために、このインターフェースに沿わなければなりません。

2. サービス （Service） は、 何らかの役に立つビジネス・ロジックを提供するクラスです。

3. プロキシー （Proxy） クラスには、サービス・オブジェクトを指す参照フィールドがあります。 プロキシーの行うべき処理 （たとえば、 遅延初期化、 ロギング、 アクセス制御、 キャッシュ処理など） が完了すると、 プロキシーは、サービス・オブジェクトにリクエストを渡します。通常、プロキシーはサービス・オブジェクトのライフサイクルを完全に管理します。

4. クライアント （Client） は、 同じインターフェースを介してサービスとプロキシーの両方で動作します。 こうすることで、 サービス・オブジェクトを期待するどんなコードにでもプロキシーを渡すことができます。

## 実装方法
1. 既存のサービス・インターフェースがない場合は、 プロキシーとサービス・オブジェクトを交換可能にするために、 インターフェースを作成します。 サービス・クラスからインターフェースを抽出することは、 必ずしも可能ではありません。 というのは、 そのサービスを使用しているすべてのクライアントを変更する必要が出てくるからです。 次善の策としては、 プロキシーをサービス・クラスのサブクラスにすることです。 これによりサービスのインターフェースを継承します。

2. プロキシー・クラスを作成します。 サービスへの参照を保存するためのフィールドを持っている必要があります。 通常、 プロキシーは、 サービスを作成し、 その後のライフサイクルを生涯に渡り管理します。 稀にですが、 クライアントはコンストラクターを介してサービスをプロキシーに渡すことがあります。

3. 目的に応じて、 プロキシーにいくつかのメソッドを実装します。 ほとんどの場合、 何らかの作業を行った後、 プロキシーは仕事をサービス・オブジェクトに委任します。

4. 生成メソッドを作成することを検討してください。 それは、 クライアントにプロキシーを渡すべきか、 本物のサービスを渡すべきかを決めます。 プロキシー・クラス中の静的メソッドとして実装することも、 一人前のファクトリー・メソッドとして実装することもできます。

5. サービス・オブジェクトの遅延初期化の実装を検討してください。

## 他のパターンとの関係
- Adapter はラップされたオブジェクトに対しては異なるインターフェースを提供し、 Proxy は同じインターフェースを提供し、 Decorator は強化したインターフェースを提供します。

- Facade は、 どちらも複雑な実体の緩衝材として機能し、 初期化も行うという意味で、 Proxy と似てます。 Facade と異なり、 Proxy はそのサービス・オブジェクトと同じインターフェースを持ち、 両者は交換可能です。

- Decorator と Proxy とは似たような構造をしていますが、 その意図は非常に異なります。 どちらのパターンも、 合成 （コンポジション） の原則に基づいており、 あるオブジェクトが仕事の一部を別のオブジェクトに委任します。 違いは、 Proxy は通常そのサービス・オブジェクトのライフサイクルの管理を行うのに対し、 Decorators では、 常にクライアントが管理するという点です。

## 引用元

> https://refactoring.guru/ja/design-patterns/proxy
> https://refactoring.guru/images/patterns/content/proxy/proxy.png
> https://refactoring.guru/images/patterns/diagrams/proxy/structure-indexed.png