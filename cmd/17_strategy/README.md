# Strategy
Strategy（ストラテジー、戦略）は、アルゴリズムのファミリーを定義し、それぞれのアルゴリズムを別個のクラスとしそれらのオブジェクトを交換可能にする

![strategy](https://refactoring.guru/images/patterns/content/strategy/strategy.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/strategy/structure-indexed.png)

1. コンテキスト （Context） は、 複数の具象ストラテジーのいずれか一つへの参照を維持し、 ストラテジー・インターフェースのみを介してこのオブジェクトと通信します。

2. ストラテジー （Strategy） インターフェースは、 すべての具象ストラテジーに共通です。 コンテキストがストラテジーを実行するために使用するメソッドを宣言します。

3. 具象ストラテジー （Concrete Strategy） は、 コンテキストが使用するアルゴリズムを種々の違う方法で実装します。

4. アルゴリズムの実行が必要となるたびに、 コンテキストはリンク先ストラテジー・オブジェクトの実行メソッドを呼びます。 コンテキストは、 どのような種類のストラテジーを相手に動作するのか、 どのようにアルゴリズムが実行されるかは認知しません。

5. クライアント （Client） は、 特定のストラテジーのオブジェクトを作成し、 コンテキストに渡します。 コンテキストは、 setter を公開しており、 クライアントは実行時にそれを使ってストラテジーを置き換えます。

## 実装方法
1. コンテキスト・クラス内で、 頻繁に変更されそうなアルゴリズムを見つけてください。 同じアルゴリズムの変種の切り替えを実行するための条件分の塊がその目印になるかもしれません。

2. アルゴリズムの変種間で共通となるストラテジー・インターフェースを宣言します。

3. アルゴリズムの変種全部を一つずつ個別のクラスに抽出します。 クラスはストラテジー・インターフェースを実装するようにします。

4. コンテキスト・クラス中に、 ストラテジー・オブジェクトへの参照を格納するためのフィールドを追加します。 そのフィールドの値を置き換えるための setter セッターを書き加えてください。 コンテキストはストラテジー・インターフェースを介してのみストラテジー・オブジェクトを使用する必要があります。 コンテキストは、 ストラテジーがデータにアクセスできるようにするためのインターフェースを定義してもかまいません。

5. コンテキストのクライアントは、 コンテキストの主な任務を実行するのに適切と思われるストラテジーとコンテキストを関連付ける必要があります。


## 他のパターンとの関係
- Bridge、 State、 Strategy （と限られた意味合いでは、 Adapter も） は、 非常に似た構造をしています。 実際のところ、 これらの全てのパターンは、 合成に基づいており、 仕事を他のオブジェクトに委任します。 しかしながら、 違う問題を解決します。 パターンは、 単にコードを特定の方法で構造化するためのレシピではありません。 パターンが解決する問題に関して、 開発者同士がするコミュニケーションの道具でもあります。

- Command と Strategy は、 オブジェクトを何らかの操作でパラメーター化できるため、 似たように見えます。 しかし、 この二つはまったく異なる意図を持っています。

  - Command を使用して、 任意の操作をオブジェクトに変換できます。 操作のパラメーターは、 そのオブジェクトのフィールドになります。 変換により、 操作の実行を延期したり、 キューに入れたり、 コマンド履歴を保存したり、 遠隔サービスにコマンドを送信したりできます。

  - 一方、 Strategy は通常、 同じことを行う異なる方法に関するものです。 単一のコンテキスト・クラス内でアルゴリズムを入れ替えることができます。

- Decorator がオブジェクトの表層を変えるのに対し、 Strategy は中身を変えます。

- Template Method は、 継承に基づくもので、 サブクラスでその一部を拡張することによって、 アルゴリズムを部分的に変更できます。 Strategy は、 合成に基き、 オブジェクトの振る舞いを、 新しい振る舞いに関連した異なるストラテジーを与えることにより変更します。 Template Method は、 クラスのレベルで機能するので、 静的です。 Strategy はオブジェクトのレベルで機能するため、 実行時に動作を切り替えることができます。

- State は、 Strategy の拡張と考えることができます。 どちらのパターンも合成 （コンポジション） に基づいており、 コンテキストの振る舞いの変更を、 ヘルパー・オブジェクトに仕事の一部を委任することにより行います。 Strategy では、 これらのオブジェクトは完全に独立しており、 互いを意識しません。 しかし、 State では、 具象状態間の依存関係を制限せず、 コンテキストの状態を自由に変更できます。

## 引用元

> https://refactoring.guru/ja/design-patterns/strategy
> https://refactoring.guru/images/patterns/content/strategy/strategy.png
> https://refactoring.guru/images/patterns/diagrams/strategy/structure-indexed.png