# Memento
Memento（メメント、形見）は、オブジェクトの以前の状態を保存し復元することを実装の詳細を明かさずに行う

![memento](https://refactoring.guru/images/patterns/content/memento/memento-ja.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/memento/structure1-indexed.png)

1. オリジネーター （Originator） クラスは、 自身の状態のスナップショットを作成することと、 必要に応じてスナップショットから状態を復元することができます。

2. メメント （Memento） は、 オリジネーターの状態のスナップショットとして機能する値オブジェクトです。 メメント・オブジェクトは変更不可とし、 コンストラクターを介して一度だけデータを渡すことが、 よく行われるやり方です。

3. Caretaker は、 いつ、 どうして、 オリジネーターの状態を獲得すべきかを知っているだけでなく、 いつ状態を復元すべきかも知っています。ケアテーカーは、 メメントのスタックを保存することによって、 オリジネーターの履歴を追跡することができます。 オリジネーターが履歴をさかのぼる必要のある時は、 スタックから一番上のメメントを取り出し、 オリジネーターの復元メソッドに渡します。

4. この実装では、 メメントのクラスはオリジネーターの中にネストされます。 これにより、 オリジネーターは非公開と宣言されているメメントのフィールドとメソッドにアクセスできます。 一方、 ケアテーカーからのメメントのフィールドやメソッドへのアクセスは非常に制限されており、 スタックにメメントを収めることはできますが、 状態の改竄はできません。

## 実装方法
1. どのクラスがオリジネーターの役割を果たすのかを決定します。 プログラムが、 この型のオブジェクト 1 個を中心として使うのか、 それとも複数の小さなオブジェクトを使うのかを知ることが重要です。

2. メメント・クラスを作成します。 オリジネーター内で宣言されたフィールドに対応するフィールドを一つずつ宣言していきます。

3. メメントのクラスを不変とします。 メメントは、 コンストラクターを介してのみデータを受け取ります。 クラスに setter があっってはなりません。

4. プログラミング言語がネストされたクラスをサポートしている場合は、 メメントは、 オリジネーターの内部の入れ子クラスにします。 そうでない場合は、 空 （から） のインターフェースを作成し、 メメント・クラスがそれを実装するようにし、 他のすべてのオブジェクトはメメント・クラスではなく、 インターフェースを参照するようにします。 インターフェースにいくつかのメタデータに対するメソッドを追加するのはかまいませんが、 オリジネーターの状態を露呈するものは避けてください。

5. オリジネーター・クラスにメメントを生成するメソッドを追加します。 オリジネーターは、 メメントのコンストラクターの 1 個または複数の引数を介してその状態を渡します。メソッドの戻り値の型は、 前段階で抽出した （抽出したとして） インターフェースとします。 内部では、 メメントの作成メソッドは メメント・クラスと直接やりとりをします。

6. オリジネーターの状態を復元するメソッドを一つ、 クラスに追加します。 それは、 メメント・オブジェクトを引数として取るようにします。 前段階でインターフェースを抽出した場合は、 それをパラメーターの型とします。 この場合、 受け取るオブジェクトをメメント・クラスに型変換 （キャスト） する必要があります。 オリジネーターはそのオブジェクトへの完全アクセスが必要だからです。

7. ケアテーカー （コマンド・オブジェクトかもしれませんし、 履歴かもしれませんし、 まったく違うものかもしれません） は、 オリジネーターにいつ新規メメントを要求するべきか、 それをどう保存するのか、 そしていつ特定のメメントでオリジネーターを復元するべきか、 を知っている必要があります。

8. ケアテーカーとオリジネーター間のリンクを、 メメントに置いておく場合もあります。 その場合は、 それぞれのメメントは、 それを作成したオリジネーターと接続されている必要があります。 復元メソッドをメメント・クラスに移動する場合もあります。 しかしこれが意味をなすのは、 メメント・クラスがオリジネーターの中にネストされているか、 オリジネーターにその状態を変更させるに十分な setter の組がある場合に限ります。


## 他のパターンとの関係
- Command と Memento とを一緒に使用して、 ​ 「取り消す」 を実装可能です。 この場合、 コマンドは、 一つのターゲット・オブジェクトに対して異なる操作を実行する責任を負い、 メメントは、 コマンド実行前にオブジェクトの状態を保存します。

- 現在の反復状態を獲得し、 必要に応じてロールバックするために、 Memento を Iterator と一緒に使用できます。

- 場合によっては、 Prototype を Memento の代わりに使用した方が簡単な場合があります。 状態の履歴を保存したいオブジェクトが比較的単純で、 他の外部リソースへのリンクを持たないか簡単に再現できる場合に、 この方法が使えます。

## 引用元

> https://refactoring.guru/ja/design-patterns/memento
> https://refactoring.guru/images/patterns/content/memento/memento-ja.png
> https://refactoring.guru/images/patterns/diagrams/memento/structure1-indexed.png