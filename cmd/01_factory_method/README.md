# Factory Method

スーパークラスでオブジェクトを作成するためのインターフェースが決まっている
しかし、 サブクラスでは作成されるオブジェクトの型を変更することができる

![factory method](https://refactoring.guru/images/patterns/content/factory-method/factory-method-ja.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/factory-method/structure-indexed.png)

1. プロダクト （Product） は、 クリエーターとそのサブクラスによって生成されるすべてのオブジェクトに共通なインターフェースを宣言します。

2. 具象プロダクト （Concrete Product） は、 プロダクトのインターフェースの種々の異なる実装です。

3. クリエーター （Creator） クラスは、 新しいプロダクトのオブジェクトを返すファクトリー・メソッドを宣言します。 このメソッドの戻り値の型がプロダクトのインターフェースと一致していることが要点です。ファクトリー・メソッドを abstract と宣言して、 すべてのサブクラスに独自のメソッドの実装を強制することができます。 代わりの方法としては、 基底クラスのファクトリー・メソッドで、 何らかのデフォルトのプロダクト型を返すようにもできます。その名前にもかかわらず、 プロダクトの作成はクリエーターの主要任務ではありません。 通常、 クリエーター・クラスはすでにプロダクトに関連するいくつかの中核となるビジネス・ロジックを持っています。 ファクトリー・メソッドは、 このロジックを具象クラスから分離するのに役立ちます。 比喩を使うとこういうことです： 大規模ソフトウェア開発会社にはプログラマーのための研修部門があるが、 会社全体の主な機能は、 コードを書くことであって、 プログラマーを育成することではない。

4. 具象クリエーター （Concrete Creator） は、 異なる型のプロダクトを返すように、 基底クラスのファクトリー・メソッドを上書きします。ファクトリー・メソッドは、 常に新しいインスタンスを作成する必要はないことに注意してください。 キャッシュ、 オブジェクト・プール、 その他の方法で既存のオブジェクトを返してもかまいません。

## 実装方法
1. すべてのプロダクトが同じインターフェースに従うようにします。 このインターフェースでは、 すべてのプロダクトにとって意味のあるメソッドを宣言する必要があります。

2. クリエーター・クラス内に空のファクトリー・メソッドを追加します。 メソッドの戻り値の型は、 共通のプロダクト・インターフェースと一致する必要があります。

3. クリエーターのコード内で、 プロダクトのコンストラクターの参照を全部探し出します。 プロダクト作成コードをファクトリー・メソッドに抽出しながら、 一つずつ、 コンストラクター呼び出しをファクトリー・メソッドへの呼び出しで置き換えていきます。ファクトリー・メソッドに、 プロダクトの戻り値の型を決めるためのパラメーターを一時的に追加する必要があるかもしれません。この時点では、 ファクトリー・メソッドのコードはあまりきれいなものではないかもしれません。 どのプロダクトのクラスをインスタンス化するかを選択するかを決める巨大な switch 文の塊になっているかもしれません。 しかし、 これはすぐ修正するので、 心配は無用です。

4. 次に、 ファクトリー・メソッドに並んでいるプロダクトの型ごとに、 クリエーターのサブクラスを作成します。 基底クラスのファクトリー・メソッドの構築コードの該当部分を抽出して、 それでサブクラスのファクトリー・メソッドを上書きします。

5. プロダクトの型が多すぎて、 すべての型に応じたサブクラスを作成することがあまり現実的ではない場合は、 基底クラスに追加した制御パラメーターを再利用できます。たとえば、 次のようなクラスの階層があるとします： 基底クラスである Mail （郵便） クラスとそのサブクラス、 Air­Mail （航空便） と Ground­Mail （陸送便）、 Transport （運輸） クラスとして Plane （飛行機）、 Truck （トラック）、 Train （鉄道）。 Air­Mail クラスは Plane オブジェクトのみを使用しますが、 Ground­Mail は Truck と Train 両方のオブジェクトを扱うことができます。 両方のケースを扱うために新しいサブクラス、 たとえば Train­Mail （鉄道便） を作ることもできます。 が、 もう一つ選択肢としては、 クライアント・コードが Ground­Mail クラスのファクトリー・メソッドを引数として渡して、 どちらのプロダクトを受け取りたいかを伝えるようにすることです。

6. すべての抽出作業の後、 基底クラスのファクトリー・メソッドが空になった場合は、 そのクラスを抽象クラスとすることができます。 何か残った場合は、 それをメソッドのデフォルト動作とすることができます。

## 他のパターンとの関係
- 多くの設計は、 まず比較的単純でサブクラスによりカスタマイズ可能な、 Factory Method から始まり、 次第に、 もっと柔軟だが複雑な Abstract Factory や Prototype や Builder へと発展していきます。

- Abstract Factory クラスは、 多くの場合 Factory Methods の集まりですが、 Prototype を使ってメソッドを書くこともできます。

- Factory Method を Iterator と一緒に使って、 コレクションのサブクラスが、 コレクションと互換な、 異なる型のイテレーターを返すようにできます。

- Prototype は継承に基づいていないので、 継承の欠点はありません。 一方、 Prototype は、 クローンされたオブジェクトの複雑な初期化が必要となります。 Factory Method は継承に基づいていますが、 初期化のステップは必要ありません。

- Factory Method は、 Template Method の特別な場合です。 同時に、 Factory Method は、 大きな Template Method の一つのステップとして使うこともできます。

## 引用元
> https://refactoring.guru/ja/design-patterns/factory-method
> https://refactoring.guru/images/patterns/content/factory-method/factory-method-ja.png
> https://refactoring.guru/images/patterns/diagrams/factory-method/structure-indexed.png