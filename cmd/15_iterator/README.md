# Iterator
リスト、スタック、ツリーなどの実際のデータ表現を表に出さずにコレクションの要素を探索することが可能。

![iterator](https://refactoring.guru/images/patterns/content/iterator/iterator-ja.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/iterator/structure-indexed.png)

1. パイテレーター （Iterator） インターフェースは、 コレクションを探索するために必要な操作、 つまり、 次要素の獲得、 現在位置の取得、 探索のリセットなどを宣言します。

2. 具象イテレーター （Concrete Iterator） は、 コレクションを探索するための特定のアルゴリズムを実装します。 イテレーター・オブジェクトは、 探索の進行状況を独自に把握する必要があります。 これにより、 複数のイテレーターが同じコレクションを互いに独立して探索することができます。

3. コレクション （Iterable Collection） インターフェースは、 コレクションと互換なイテレーターを取得するための一つまたは複数のメソッドを宣言します。 具象コレクションが様々な種類のイテレーターを返せられるように、 メソッドの戻り値型はイテレーター・インターフェースとして宣言されなければいけないことに注意してください。

4. 具象コレクション （Concrete Collection） は、 クライアントから要求があるたびに、 特定の具象イテレーター・クラスの新インスタンスを返します。 コレクションの残りのコードはどこにあるのだろう、 と思ってませんか？ 大丈夫、 同じクラスにあるはずです。 このような細いことは実際のパターンにとっては重要ではないので、 省略しているだけです。

5. クライアント （Client） は、 コレクションとイテレーターの両方と、 それぞれのインターフェースを介してやりとりをします。 これにより、 クライアントは具体的なクラスに結合されることなく、 同じクライアント・コードで様々なコレクションやイテレーターを使用することができます。多くの場合、 クライアントは自分でイテレーターを作成することはせず、 コレクションから取得します。 しかし特別な場合、 クライアントはイテレーターを直接作成できます。 クライアントが専用の特殊イテレーターを定義した場合などです。

## 実装方法
1. イテレーター・インターフェースを宣言します。 少なくとも、 コレクションから次の要素を獲得するためのメソッドを持つ必要があります。 しかし、 利便性を考え、 前要素の獲得、 現在位置の確認、 探索終了チェックなど、 いくつかの他のメソッドを追加することもできます。

2. コレクションのインターフェースを宣言し、 イテレーター取得メソッドを記述します。 戻り値の型はイテレーター・インターフェースにする必要があります。 いくつかの異なるイテレーターを作る予定の場合は、 似たようなメソッドをいくつか宣言してもかまいません。

3. イテレーターで探索したいコレクションに対して具象イテレーター・クラスを実装します。 イテレーター・オブジェクトはコレクションのインスタンス一つとリンクされている必要があります。 通常、 このリンクはイテレーターのコンストラクターを介して確立されます。

4. コレクション・インターフェースを実装してコレクション・クラスを作成します。 基本的な考え方としては、 特定のコレクション・クラス用に調整されたイテレーターを作成するための近道をクライアントに提供するということです。 コレクション・オブジェクトは、 イテレーターのコンストラクターに自身を渡して、 リンクを確立する必要があります。

5. クライアント・コードを見渡して、 すべてのコレクションの探索コードをイテレーターの使用に置き換えます。 クライアントは、 コレクション要素を反復する必要があるたびに、 新しいイテレーター・オブジェクトを獲得します。

## 他のパターンとの関係
- Iterators を使用して Composite ツリーを探索することができます。

- Factory Method を Iterator と一緒に使って、 コレクションのサブクラスが、 コレクションと互換な、 異なる型のイテレーターを返すようにできます。

- 現在の反復状態を獲得し、 必要に応じてロールバックするために、 Memento を Iterator と一緒に使用できます。

- 複雑なデータ構造を探索し、 その要素に対してある操作を実行するために、 Visitor を Iterator と一緒に使用することができます。 要素のクラスが全部異なっていてもかまいません。

## 引用元

> https://refactoring.guru/ja/design-patterns/iterator
> https://refactoring.guru/images/patterns/content/iterator/iterator.png
> https://refactoring.guru/images/patterns/diagrams/iterator/structure-ja-indexed.png