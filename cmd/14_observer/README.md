# Observer
サブスクリプション（通知申し込み）の仕組みを定義することにより、観察対象オブジェクトに何かイベントが発生した時、そのイベントの観察者である複数のオブジェクトへ通知を行う

![observer](https://refactoring.guru/images/patterns/content/observer/observer.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/observer/structure-indexed.png)

1. パブリッシャー （Publisher） は、 他のオブジェクトが関心を持つイベントを発行します。 パブリッシャーがその状態を変えた時や何らかの行為を行なった時に、 このようなイベントが発生します。 パブリッシャーには、 サブスクリプションの仕組みがあり、 新規サブスクライバーの参加や現サブスクラーバーの参加を取り消すことができます。

2. 新しいイベントが発生すると、 パブリッシャーはサブスクリプション・リストにアクセスし、 各サブスクライバー・オブジェクトのサブスクライバー・インターフェースで宣言された通知メソッドを呼び出します。

3. サブスクライバー （Subscriber） インターフェースは通知用インターフェースを宣言します。 ほとんどの場合、 update メソッド一つだけがあります。 このメソッドには、 更新時にパブリッシャーがイベントの詳細情報を渡せるようにいくつかパラメータを持たせることもできます。

4. 具象サブスクライバー （Concrete Subscribers） は、 パブリッシャーが発行した通知に応じて何らかのことを行います。 これらのクラスは、 パブリッシャーが具体的なクラスに結合されずにすむように、 すべて同じインターフェースを実装しなければなりません。

5. 通常、 サブスクライバーは、 更新を正しく処理するために周辺情報を必要とします。 このため、 パブリッシャーは、 通知メソッドの引数として周辺データを渡すことがよくあります。 パブリッシャーは引数として自分自身を渡すことができ、 サブスクライバーは必要なデータを直接取得することができます。

6. Client （クライアント） は、 パブリッシャーとサブスクライバーのオブジェクトを別々に作成し、 パブリッシャーの更新に対してサブスクライバーを登録します。

## 実装方法
1. ビジネス・ロジックを眺めて、 これを二つの部分に分けます。 他のコードから独立した中核機能はパブリッシャーとして機能し、 残りはサブスクライバー・クラスの集合となります。

2. サブスクライバー・インターフェースを宣言します。 最低でも、 update メソッドを一つ宣言します。

3. パブリッシャー・インターフェースを宣言し、 サブスクライバー・オブジェクトをリストに追加と削除を行うメソッドのペアを書き入れます。 パブリッシャーはサブスクライバーとサブスクライバー・インターフェースを通してのみやりとりすることをお忘れなく。

4. どこに実際のサブスクリプション・リストを置くかを決め、 サブスクリプション用メソッドを実装します。 このコードは、 通常すべてのパブリッシャー間で同じなので、 これを置くのに自明な場所は、 パブリッシャー・インターフェースから直接派生した抽象クラスです。 具象クラスはそのクラスを拡張し、 サブスクリプションの振る舞いを継承します。しかしながら、 既存のクラス階層にこのパターンを適応する場合は、 合成に基づく方法を検討してください。 つまり、 サブスクリプションのロジックを個別のオブジェクトに置き、 実際の全パブリッシャーがそれを使うようにします。

5. パブリッシャーの具象クラスを作成します。 何か重要なことがパブリッシャーの中で起きるたびに、 サブスクライバー全部に通知しなければいけません。

6. 具象サブスクライバー・クラスの中に更新通知メソッドを実装します。 大多数のサブスクライバーは、 イベントについて何らかの周辺情報を必要とします。 それは、 通知メソッドの引数として渡すことができます。しかし、 もう一つのやり方があります。 通知を受けたらすぐ、 サブスクライバーはそのデータを通知から直接取り込むことができます。 この場合、 パブリッシャーはそれ自身を更新メソッドを通して渡します。 少し柔軟性に欠けますが、 コンストラクターを通して、 パブリッシャーをサブスクライバーと永久にリンクすることもできます。

7. クライアントは、 必要なすべてのサブスクライバーを作成し、 それらを適切なパブリッシャーに登録する必要があります。

## 他のパターンとの関係
- Chain of Responsibility と Command と Mediator と Observer は、 リクエストの送り手と受け手を接続する様々な方法を示します：

  - Chain of Responsibility は、 潜在的受け手の動的な連鎖に沿って、 どれか一つが処理するまで、 リクエストを順番に渡します。
  - Command は、 送り手と受け手との間で単方向の接続を確立します。
  - Mediator は、 送り手と受け手の間の直接の接続を削除し、 メディエーター・オブジェクトを介しての間接的通信を強制します。
  - Observer では、 受け手が動的にリクエストの受信申し込みをしたり、 申し込み取り消しをしたりできます。

  - Mediator と Observer との違いは、 理解に苦しむことがあります。 ほとんどの場合、 これらのパターンのいずれかを実装すればいですが、 両方を同時に適用することもできます。 どうすればそれができるか見てみましょう。

  - Mediator の主目的は、 システム構成コンポーネント間の相互依存をなくすことです。 その代わりに、 これらのコンポーネントは単一のメディエーター・オブジェクトに依存するようになります。 Observer の主目的は、 オブジェクト間の動的な単方向の接続を確立することにあり、 そこではあるオブジェクトが他のオブジェクトの部下として動作します。

  - Observer に依存した、 Mediator パターンの有名な実装方法があります。 メディエーター・オブジェクトがパブリッシャーとしての役割を果たし、 他のコンポーネントがサブスクライバーとしてメディエーターのイベントに通知依頼をしたり依頼解除をします。 このように Mediator を実装すると、 Observer と非常に似たよう見えます。

  - 混乱した時は、 Mediator パターンは、 他の方法でも実装できるということを忘れないでください。 たとえば、 同一のメディエーター・オブジェクトにすべてのコンポーネントを恒久的にリンクできます。 この実装方法は、 Observer には似ていませんが、 Mediator パターンの適用例の一つと言えます。

  - ここで、 プログラム中のすべてのコンポーネントがパブリッシャーとなり、 お互いに動的な接続が許された状況を想像してみてください。 ここでは、 中心となるメディエーター・オブジェクトはなく、 分散されたオブザーバーの集団があるだけです。

## 引用元

> https://refactoring.guru/ja/design-patterns/observer
> https://refactoring.guru/images/patterns/content/observer/observer.png
> https://refactoring.guru/images/patterns/diagrams/observer/structure-ja-indexed.png