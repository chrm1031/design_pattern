# Decorator
ある振る舞いを含む特別なラッパー・オブジェクトの中にオブジェクトを配置することで、それらのオブジェクトに新しい振る舞いを付け加える

![decorator](https://refactoring.guru/images/patterns/content/decorator/decorator.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/decorator/structure-indexed.png)

1. コンポーネント （Component） は、 ラッパーとラップされるオブジェクトとの共通インターフェースを宣言します。

2. 具象コンポーネント （Concrete Component） は、 ラップされるオブジェクトのクラスで、 デコレーターによって変更できる基本的な振る舞いを定義します。

3. 基底デコレーター （Base Decorator） クラスには、 ラップされたオブジェクトを参照するためのフィールドがあります。 フィールドの型は、 具象コンポーネントとデコレーターの両方を含むことができるように、 コンポーネント・インターフェースとして宣言する必要があります。 基底デコレーターは、 すべての操作をラップされたオブジェクトに委任します。

4. 具象デコレーター （Concrete Decorator） は、 コンポーネントに動的に追加可能な振る舞いを定義します。 具象デコレーターは、 基底デコレーターのメソッドを上書きし、 親メソッドを呼び出す前または後に追加の振る舞いのコードを実行します。

5. クライアント （Client） は、 コンポーネント・インターフェースを介してすべてのオブジェクトとやりとりする限り、 コンポーネントを複数のデコレーターの層でラップできます。

## 実装方法
1. プログラムの処理対象が、 一つの主要コンポーネントと、 それに追加可能な複数の層として表現可能なことを確認してください。

2. 主要コンポーネントと追加の層に共通なメソッドは何かを考え出してください。 そのようなメソッドを列挙した共通インターフェースを宣言します。

3. 具象コンポーネント・クラスを作成し、 その中で基本動作を定義します。

4. デコレーターの基底クラスを作成します。 ラップされたオブジェクトへの参照を記憶するためのフィールドが必要となります。 このフィールドの型は、 具象コンポーネントとデコレーターのどちらにでもリンクできるよう、 コンポーネント・インターフェースとして宣言される必要があります。 基底デコレーターは、 すべての操作をラップされたオブジェクトに委任します。

5. すべてのクラスがコンポーネント・インターフェースを実装していることを確認してください。

6. デコレーターの基底クラスを拡張して、 具象デコレーターを作成します。 具象デコレーターは、 親のメソッド （親メソッドは常にラップされたオブジェクトに委任） を呼ぶ前か呼んだ後に、 それ自身の追加の振る舞いを実行します。

7. デコレーターを作成し、 クライアントの必要に応じてそれを組み合わせるのは、 クライアント・コードの責任となります。

## 他のパターンとの関係
- Adapter は既存のオブジェクトのインターフェースを変更するのに対し、 Decorator はインターフェースの変更なしにオブジェクトを強力にします。 さらに、 Decorator は、 再帰的な合成をサポートします。 これは、 Adapter を使用する時には不可能です。

- Adapter はラップされたオブジェクトに対しては異なるインターフェースを提供し、 Proxy は同じインターフェースを提供し、 Decorator は強化したインターフェースを提供します。

- Chain of Responsibility と Decorator とは非常によく似た階層構造をしています。 両パターンとも、 一連のオブジェクトを通して実行を渡すために、 再起的合成に依存します。 しかしながら、 いくつかの重要な違いがあります。CoR ハンドラーは、 互いに独立して任意の処理を実行可能です。 また、 任意の時点でそれ以上リクエストを渡すのを止めることもできます。 一方、 様々な Decorator では、 オブジェクトの振る舞いの拡張をする時、 基底インターフェースとの一貫性を保つ必要があります。 さらに、 デコレーターはリクエストの流れを断ち切ることは許されていません。

- Composite と Decorator は両方とも、 任意の数のオブジェクトを組織するために再起的合成を使用するので、 似たような構造図をしています。Decorator は、 Composite に似ていますが、 子コンポーネントは一つしかありません。 もう一つの大きな違いは、 Decorator は内包するオブジェクトに責任を追加するのに対し、 Composite は、 単にその子たちの結果を 「まとめあげる」 だけです。しかしながら、 これらのパターンは互いに協力できます。 Decorator を使用して、 Composite ツリー内の特定のオブジェクトの振る舞いを拡張できます。

- Composite と Decorator を多用する設計に対しては、 Prototype の使用が有益かもしれません。 このパターンを適用すると、 複雑な構造を初めから再構築するのではなく、 それをクローンします。

- Decorator がオブジェクトの表層を変えるのに対し、 Strategy は中身を変えます。

- Decorator と Proxy とは似たような構造をしていますが、 その意図は非常に異なります。 どちらのパターンも、 合成 （コンポジション） の原則に基づいており、 あるオブジェクトが仕事の一部を別のオブジェクトに委任します。 違いは、 Proxy は通常そのサービス・オブジェクトのライフサイクルの管理を行うのに対し、 Decorators では、 常にクライアントが管理するという点です。

## 引用元

> https://refactoring.guru/ja/design-patterns/decorator
> https://refactoring.guru/images/patterns/content/decorator/decorator.png
> https://refactoring.guru/images/patterns/diagrams/decorator/structure-indexed.png