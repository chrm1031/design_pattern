# Composite
オブジェクトからツリー（木）構造を組み立て、そのツリー構造がまるで独立したオブジェクトであるかのように扱えるようにする

![composite](https://refactoring.guru/images/patterns/content/composite/composite.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/composite/structure-ja-indexed.png)

1. コンポーネント （Component） インターフェースは、 ツリーの単純な要素と複雑な要素の両方に共通する操作を記述します。

2. リーフ （Leaf） は、 ツリーの基本要素で、 子要素を持ちません。リーフのコンポーネントは、 仕事の移譲先がないため、 通常、 実際の作業のほとんどは、 ここで行われることになります。

3. コンテナ （Container、 別名： Composite） は、 子要素を持った要素です。 コンテナはその子要素の具象クラスが何なのかを知らず、 コンポーネント・インターフェースを介してのみ、 子要素とやりとりをします。リクエストを受け取ると、 コンテナはその作業を子要素に委任し、 中間結果を処理し、 最終結果をクライアントに返します。

4. クライアント （Client） は、 コンポーネントインターフェースを介してすべての要素とやりとりします。 その結果、 クライアントは、 ツリーの単純要素と複雑な要素の両方に対して同じように機能できます。

## 実装方法
1. アプリの中核のモデルが、 ツリー構造で表現可能なことをまず確認してください。 単純項目とコンテナに分けてみてください。 コンテナは、 単純要素と他のコンテナを含むことができる、 ということをお忘れなく。

2. 単純要素と複合要素の両方に意味のあるメソッドを並べたコンポーネント・インターフェースを宣言してください。

3. 単純要素を表現する、 リーフ・クラスを作成します。 一つのプログラムには、 複数のリーフ・クラスがあるかもしれません。

4. 複雑な要素を表現する、 コンテナ・クラスを作成します。 このクラスには、 子要素への参照をしまっておくための配列フィールドを設けます。 配列は、 リーフとコンテナの両方をしまうことが可能である必要があります。 そのため、 コンポーネント・インターフェースを使って宣言してください。コンポーネント・インターフェースのメソッド実装の際には、 コンテナがほとんどの作業を子要素に委任するべきだということをお忘れなく。

5. 最後に、 コンテナに子要素を追加したり削除するためのメソッドを定義してください。これらの操作は、 コンポーネント・インターフェースで宣言することもできる、 ということを心にとめておいてください。 これは、 リーフ・クラスではこれらのメソッドは空になるため、 インターフェース分離の原則に違反します。 しかし、 そうすることで、 ツリーの作成時に、 クライアントは全要素を同等に扱えます。

## 他のパターンとの関係
- Builder は、 複雑な Composite ツリー作成に使用できます。 構築ステップを再帰的に行なうように プログラムします。

- Chain of Responsibility は、 よく Composite と一緒に使われます。 この場合、 リーフ （末端） のコンポーネントがリクエストを受ける時、 リクエストは、 全部の親コンポーネントからオブジェクト・ツリーのルート （根） までを通るかもしれません。

- Iterators を使用して Composite ツリーを探索することができます。

- Visitor を使用して、 Composite ツリー全体に対して一つの操作を実行できます。

- RAM を節約するために、 Composite ツリーの共有リーフ・ノードを Flyweights として実装できます。

- Composite と Decorator は両方とも、 任意の数のオブジェクトを組織するために再起的合成を使用するので、 似たような構造図をしています。Decorator は、 Composite に似ていますが、 子コンポーネントは一つしかありません。 もう一つの大きな違いは、 Decorator は内包するオブジェクトに責任を追加するのに対し、 Composite は、 単にその子たちの結果を 「まとめあげる」 だけです。しかしながら、 これらのパターンは互いに協力できます。 Decorator を使用して、 Composite ツリー内の特定のオブジェクトの振る舞いを拡張できます。

- Composite と Decorator を多用する設計に対しては、 Prototype の使用が有益かもしれません。 このパターンを適用すると、 複雑な構造を初めから再構築するのではなく、 それをクローンします。

## 引用元

> https://refactoring.guru/ja/design-patterns/composite
> https://refactoring.guru/images/patterns/content/composite/composite.png
> https://refactoring.guru/images/patterns/diagrams/composite/structure-ja-indexed.png