# Command
Command （コマンド、 命令）は、リクエストをそれに関するすべての情報を含む独立したオブジェクトに転換する
この転換によりリクエストをメソッドの引数として渡したり、リクエストの実行を遅らせたり、待ち行列に入れたり、取り消し操作を行なうことが可能になる

![command](https://refactoring.guru/images/patterns/content/command/command-ja.png)

## 構造
![UML](https://refactoring.guru/images/patterns/diagrams/command/structure-indexed.png)

1. 送り手 （Sender） クラス、 別名インボーカー （Invoker） は、 リクエストの開始を担当します。 このクラスには、 コマンドオ・ブジェクトへの参照を保存するためのフィールドが必要となります。 送り手は、 リクエストを受け手に直接送る代わりに、 コマンドの引き金を引きます。 送り手にはコマンド・オブジェクトの作成の責任がないことに注目してください。 通常は、 クライアントからコンストラクターを介して事前に作成されたコマンドを取得します。

2. コマンド （Command） インターフェースは通常、 コマンドを実行するためのメソッドを一つ宣言します。

3. 具象コマンド （Concrete Command） は様々な種類のリクエストを実装します。 具象コマンドは、 仕事を独立して自身で行うべきではなく、 ビジネス・ロジックのオブジェクトのどれかに仕事を渡すべきです。 しかし、 コードの簡素化のためにこの二つのクラスの統合は可能です。受け手のオブジェクトでメソッドの実行に必要なパラメーターは、 具象コマンドのフィールドとして宣言することができます。 これらのフィールドの初期化をコンストラクター内だけで許可するようにすれば、 コマンド・オブジェクトは不変となります。

4. 受け手 （Receiver） クラスには、 何らかのビジネス・ロジックが含まれています。 ほとんどどんなオブジェクトでも受け手になれます。 ほとんどのコマンドは、 リクエストを受け手に渡す詳細を扱い、 実際の作業は受け手が行います。

5. クライアント （Client） は、 具象コマンド・オブジェクトの作成および構成を行います。 クライアントは、 受け手インスタンスを含むすべてのリクエスト・パラメータをコマンドのコンストラクターに渡す必要があります。 その後、 作成されたコマンドは、 一つ以上の送り手に関連付けられます。

## 実装方法
1. 実行メソッドを一つだけ持つコマンド・インターフェースを宣言します。

2. コマンド・インターフェースを実装する具象コマンド・クラスにリクエストを抽出します。 各クラスは、 リクエストの引数と、 実際の受け取りオブジェクトへの参照を格納するためのフィールドをいくつか持っている必要があります。 これら値はすべて、 コマンドのコンストラクターを通して初期化されなければなりません。

3. 送り手として機能するクラスをいくつか探し出します。 これらのクラスにコマンドを保存するためのフィールドを追加します。 送り手は、 コマンド・インターフェースを通してのみコマンドと通信する必要があります。 送り手は通常、 自身でコマンド・オブジェクトを作成することはせず、 クライアント・コードから取得します。

4. 送り手を変更して、 直接リクエストを受け手に送る代わりに、 コマンドを実行するようにします。

5. クライアントは以下の順序でオブジェクトを初期化します：

  - 受け手を作成。
  - コマンドを作成し、 必要に応じて受け手と関連付ける。
  - 送り手を作成し、 特定のコマンドに関連付ける。


## 他のパターンとの関係
- Chain of Responsibility と Command と Mediator と Observer は、 リクエストの送り手と受け手を接続する様々な方法を示します：

  - Chain of Responsibility は、 潜在的受け手の動的な連鎖に沿って、 どれか一つが処理するまで、 リクエストを順番に渡します。
  - Command は、 送り手と受け手との間で単方向の接続を確立します。
  - Mediator は、 送り手と受け手の間の直接の接続を削除し、 メディエーター・オブジェクトを介しての間接的通信を強制します。
  - Observer では、 受け手が動的にリクエストの受信申し込みをしたり、 申し込み取り消しをしたりできます。

- Chain of Responsibility のハンドラーは、 Commands で実装可能です。 この場合、 リクエストに代表される同一のコンテキスト・オブジェクトに対して多くの異なる処理を実行できます。しかしもう一つのやり方は、 リクエスト自身をコマンド・オブジェクトとすることです。 この場合、 連鎖にリンクされた異なる一連のコンテキスト中で同じ処理を実行できます。

- Command と Memento とを一緒に使用して、 ​ 「取り消す」 を実装可能です。 この場合、 コマンドは、 一つのターゲット・オブジェクトに対して異なる操作を実行する責任を負い、 メメントは、 コマンド実行前にオブジェクトの状態を保存します。

- Command と Strategy は、 オブジェクトを何らかの操作でパラメーター化できるため、 似たように見えます。 しかし、 この二つはまったく異なる意図を持っています。

  - Command を使用して、 任意の操作をオブジェクトに変換できます。 操作のパラメーターは、 そのオブジェクトのフィールドになります。 変換により、 操作の実行を延期したり、 キューに入れたり、 コマンド履歴を保存したり、 遠隔サービスにコマンドを送信したりできます。

  - 一方、 Strategy は通常、 同じことを行う異なる方法に関するものです。 単一のコンテキスト・クラス内でアルゴリズムを入れ替えることができます。

- Prototype は、 Commands のコピーを履歴に保存する必要がある場合に役立ちます。

- Visitor を Command パターンのより強力なものとして扱うことができます。 そのオブジェクトは、 異なるクラスの様々なオブジェクトに対して操作を実行できます。

## 引用元

> https://refactoring.guru/ja/design-patterns/command
> https://refactoring.guru/images/patterns/content/command/command-ja.png
> https://refactoring.guru/images/patterns/diagrams/command/structure-indexed.png